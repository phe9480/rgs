% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wlr.asym.R
\name{wlr.asym}
\alias{wlr.asym}
\title{Asymptotic Distribution of Weighted Log-rank Statistic}
\usage{
wlr.asym(
  DCO = 24,
  r = 1,
  n = 450,
  h0 = function(t) {     log(2)/12 },
  S0 = function(t) {     exp(-log(2)/12 * t) },
  h1 = function(t) {     log(2)/12 * 0.7 },
  S1 = function(t) {     exp(-log(2)/12 * 0.7 * t) },
  cuts = c(6),
  rho = 0,
  gamma = 0,
  tau = NULL,
  s.tau = 0,
  f.ws = NULL,
  Lambda = function(t) {     (t/18) * as.numeric(t <= 18) + as.numeric(t > 18) },
  G0 = function(t) {     0 },
  G1 = function(t) {     0 }
)
}
\arguments{
\item{r}{Proportion of subjects in experimental arm. For 1:1 randomization, r = 1/2.}

\item{n}{Total sample size for two arms.}

\item{h0}{Hazard function of control arm, eg, h0(t) = log(2)/m0 for the exponential distribution with median m0.}

\item{S0}{Survival function of control arm.}

\item{h1}{Hazard function of experimental arm.}

\item{S1}{Survival function of experimental arm.}

\item{cuts}{Piece wise interval cut points of the curresponding survival functions.
For delayed effect model with 6 months of delay, cuts = 6. Incorrect
specification of cuts may lead to numerical integration issues.}

\item{f.ws}{Self-defined weight function of survival rate, eg, f.ws = function(s){1/max(s, 0.25)}
When f.ws is specified, sFH parameter will be ignored.}

\item{Lambda}{Cumulative distribution function of enrollment.}

\item{G0}{Cumulative distribution function of drop-off for control arm, eg, G.ltfu=function(t){1-exp(-0.03/12*t)}
is the distribution function for 3 percent drop-off in 12 months of followup.}

\item{G1}{Cumulative distribution function of drop-off for experimental arm, eg, G.ltfu=function(t){1-exp(-0.03/12*t)}
is the distribution function for 3 percent drop-off in 12 months of followup.}

\item{T}{Analysis time, calculated from first subject in.}

\item{method}{Non-centrality parameter options: "SIGWA", "Schoenfeld", "YL 2020", "LM 2019". Default "SIGWA".
"YL 2020" is based on Yung and Liu (2020) and "LM 2019" is based on Luo et al (2019).}
}
\value{
A dataframe with variables including
\itemize{
\item  mu:     Mean of the weighted logrank test statistic Z = U/sqrt(V). E(Z) = mu = sqrt(n)*delta/sigma
\item  mu_SF:  Mean of the weighted logrank test statistic Z using Schoenfeld method. E(Z) = mu_SF = sqrt(n)*eta/sigma
\item  delta:  Mean of U/n. E(U/n)=delta = r0 * delta0 + r1 * delta1
\item  delta0: Mean of U0/n0 for control arm. E(U0/n0) = delta0
\item  delta1: Mean of U1/n1 for experimental arm E(U1/n1) = delta1
\item  eta:    Mean of U/n in weighted logrank test in Schoenfeld method. E(U/n)=eta
\item  sigma2: Estimate of V/n --> sigma2 for n large. Also, under H0, var(n^(-1/2)U) = sigma2
Under H1, var(n^(-1/2)U) = sigma2 + O(n^(-1/2)). So sigma2 is also an estimate of var(n^(-1/2)U)
\item  sigma2_b: Var(n^(-1/2)U) using Yung and Liu (2020)'s method Z ~ N(mu, sigma2_b/sigma2)
\item  sigma2_s: Var(n^(-1/2)U) using Luo et al (2019)'s method Z ~ N(mu, sigma2_s/sigma2)
\item  sigma2_h: Var(n^(-1/2)U) using He et al (2022)'s method Z ~ N(mu, sigma2_h/sigma2)
\item  R:  Location Factor. Under H1, mu = sqrt(n)*R. For a fixed sample size n, R represents the magnitude of followup.
\item  var_YL: var_YL = sigma2_b/sigma2
\item  var_LM: var_LM = sigma2_s/sigma2
\item  var_HK: var_HK = sigma2_h/sigma2
\item  pow_YL: Power for a test with rejection bound 1.96: P(Z > 1.96)=PHI((mu-1.96)*sigma/sigma_x).
2.5\% alpha with only 1 analysis.
\item  pow_LM: See pow_YL
\item  pow_HK: See pow_YL
\item  pow_SF: Power of Schoenfeld method: PHI(mu_SF-1.96)
\item  pow_mu: Power of mu method with simpler approximation: PHI(mu-1.96)
}
Another dataframe including variables: method, mean, var, pow
}
\description{
This function calculates the asymptotic distribution (mean and variance) at a DCO.
}
\examples{
#Example: Assume HR 0.65 after 6 months of delayed effect. Control arm follows
exponential distribution with median 12 months.

HR = 0.4; delay = 6; lam0 = log(2) / 12; 
h0 = function(t){lam0}; S0 = function(t){exp(-lam0 * t)}
h1.D6 = function(t){lam0*as.numeric(t < delay)+HR*lam0*as.numeric(t >= delay)}
c = exp(-delay*lam0*(1-HR)); 
S1.D6 = function(t){exp(-lam0*t)*as.numeric(t<delay) + c*exp(-HR*lam0*t)*as.numeric(t>=delay)}
f.logHR.D6 = function(t){log(as.numeric(t<6) + as.numeric(t>= 6)*HR)}
Lambda = function(t){(t/18)^1.5*as.numeric(t <= 18) + as.numeric(t > 18)}
G0.ltfu = G1.ltfu = function(t){0}

wlr.mu(DCO = 24, r = 1, n = 450, h0 = h0, S0=S0,
     h1 = h1.D6, S1=S1.D6, f.logHR = f.logHR.D6,
     rho = 0, gamma = 0, tau = NULL, s.tau = 0, f.ws = NULL,
     F.entry = Lambda)
wlr.asym(DCO = 24, r = 1, n = 450, h0 = h0, S0=S0,
     h1 = h1.D6, S1=S1.D6, 
     rho = 0, gamma = 0, tau = NULL, s.tau = 0, f.ws = NULL,
     Lambda = Lambda, cuts=c(6))
wlr.asym(DCO = 24, r = 1, n = 450, h0 = h0, S0=S0,
     h1 = h1.D6, S1=S1.D6, 
     rho = 0, gamma = 0, tau = NULL, s.tau = 0, f.ws = NULL,
     Lambda = Lambda, cuts=c(6))
wlr.asym(DCO = 24, r = 1, n = 450, h0 = h0, S0=S0,
     h1 = h1.D6, S1=S1.D6, 
     rho = 0, gamma = 0, tau = NULL, s.tau = 0, f.ws = NULL,
     Lambda = Lambda, cuts=c(6))
wlr.mu.schoenfeld(DCO = 24, r = 1, n = 450, h0 = h0, S0=S0,
     h1 = h1.D6, S1=S1.D6, f.logHR = f.logHR.D6,
     rho = 0, gamma = 0, tau = NULL, s.tau = 0, f.ws = NULL,
     F.entry = Lambda)
     
wlr.asym(DCO = 24, r = 1, n = 450, h0 = h0, S0=S0,
     h1 = h1.D6, S1=S1.D6, 
     rho = 0, gamma = 0, tau = NULL, s.tau = 0, f.ws = NULL,
     Lambda = Lambda, cuts=c(6))
wlr.asym(DCO = 24, r = 1, n = 450, h0 = h0, S0=S0,
     h1 = h1.D6, S1=S1.D6, 
     rho = 0, gamma = 0, tau = NULL, s.tau = 0, f.ws = NULL,
     Lambda = Lambda, cuts=c(6))
wlr.asym(DCO = 30, r = 1, n = 450, h0 = h0, S0=S0,
     h1 = h1.D6, S1=S1.D6, 
     rho = 0, gamma = 0, tau = NULL, s.tau = 0, f.ws = NULL,
     Lambda = Lambda, cuts=NULL)
     

}
